package su.birukov.algorithms;

/**
 * Feedback from Nikolay Plokhoi
 *
 * Задание с BinarySearch
 1) В принципе, можно сделать метод search статическим и передавать ему два параметра:
 int[] data, int target - это позволит вызывать его следующим образом: BinarySearch.search(data, 10);
 без явного создания объекта перед использованием.
 2) Сейчас возвращаемое значение ты сделал Integer для того чтобы иметь возможность показать
 отсутствие результата (null). Обычно же в таких случаях возвращают не сам элемент, а его позицию в исходном массиве.
 Т.е. если ты на вход подаешь массив и искомое значение - то вернется тебе из метода индекс,
 по которому данное значение распологается в массиве.
 Или же отрицательное значение, если данного элемента нет в массиве.
 Это общепринятый подход.
 3) По поводу тестов - ты правильно сделал что изменил System.out на ассерты,
 но закомментированный код обычно стараются не хранить в репозитории,
 если он не актуальный, поэтому стоит удалить его)
 4) Писать длинные осмысленные комментарии к ассертам бывает слишком долго и избыточно.
 Если по коду понятно что проверяется - можно его опустить.
 5) Первым аргументом в ассертах идет ожидаемое значение, вторым проверяемое. У тебя же сейчас стоит наоборот.
 6) По поводу каста к Object - можно было поступить в обратную сторону -
 Integer перевести к int: assertEquals(0, list.search(1).intValue());
 */

class BinarySearch {
    private int[] seq;

    BinarySearch (int[] seq) {
        this.seq = seq;
    }

    public Integer search (int target) {
        int low = 0;
        int high = seq.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2;
            int guess = seq[ mid ];

            if (guess == target) {
                return mid;
            }

            if (guess > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return null;
    }
}